# Single-Cycle-RISC-V-Processor

## **Architecture** :

![Screenshot 2025-06-13 162505](https://github.com/user-attachments/assets/dd77dd69-0573-4f32-a5d1-e46a74b9bbba)

## **RV32I Base Interger Instructions** :
![Pasted image 20250612215438](https://github.com/user-attachments/assets/42f40645-0751-4643-a936-5b191e5b192d)


- Now we are going to implement the following things  
     Modules
	     - [[Program Counter]]
	     - [[Instruction memory]]
	     - [[Register File]]
	     - [[ALU]]
	     - [[Data Memory]]
	     - [MUX]
	     - [[Adder]]
	 Instructions
		- [[R Type Instructions]]
		- [[I type Instructions]]
		- [[J, I and U Instructions]]
		- [[S & B Type instructions]]

**Single cycle?**
 - Every instruction begins execution on one clock edge and completes execution on the next clock edge.
 - While easier to understand, this approach is not practical, since the clock cycle must be severely stretched to accommodate the longest instruction. After designing the control for this simple computer, we will look at faster implementations with all their complexities, including exceptions


#### **Program Counter:**
- **Instruction Fetch:** Every instruction execution begins with the Program Counter (PC) providing the address to the instruction memory. The instruction memory then supplies the instruction located at that address. 
- Mux controls the next value of the Program Counter (PC). It selects between:
    - **PC + 4:** The address of the next sequential instruction (since RISC-V instructions are 4 bytes long),
    - **Branch Destination Address:** The target address if a branch is taken.
    
    The selection is controlled by a gate that performs a logical AND between:
    - The **Zero output of the ALU** (indicating if a branch condition is met, such as equality),
    - A **control signal** that specifies whether the current instruction is a branch.
    This ensures the PC updates to the branch target only if the branch condition is true.

#### **Instruction Memory:
- It stores the program instructions.
- It is **read-only** during normal operation of the processor because the datapath only fetches instructions; it does not write to instruction memory.
- Since it only performs reads, it behaves like **combinational logic**: the output (the instruction) at any moment directly reflects the contents at the address input (provided by the PC).
- No explicit read control signal is necessary because the instruction memory continuously outputs the instruction at the given address.
- Writing to instruction memory (e.g., loading a program) is done separately, outside the normal datapath operation, and is typically not part of the processor’s runtime behavior.

#### **Register File:**
- Inputs 5 bit wide register (which reg to choose), Outputs the contents in the read registers.
- Contains all the processor's registers.
- Has **two read ports** and **one write port**, allowing two registers to be read simultaneously and one register to be written per clock cycle.
- The register file outputs the contents of the registers specified by the 5-bit wide Read register inputs continuously, without needing additional control signals for reading.
- Writing to the register file requires asserting a **write control signal** at the clock edge, making writes **edge-triggered**.
- This edge-triggered design allows reading and writing the same register within one clock cycle safely: the read will return the value written in a previous cycle, and the new value will be available for reads in the next cycle.
- Data lines carrying register values are 32 bits wide, reflecting the 32-bit architecture of RISC-V registers.

#### **ALU (Arithmetic Logic Unit):**
- Performs the arithmetic and logical operations required by R-format instructions.
- The specific operation performed by the ALU is controlled by a **4-bit ALU operation signal**, which selects the desired function (such as addition, subtraction, AND, OR, etc.).
- The ALU also provides a **Zero detection output**, which is used to implement conditional branches by indicating whether the ALU result is zero (e.g., for equality checks).
  
##### **ALU Functions and Control Lines**
The RISC-V ALU supports four main operations selected by a 4-bit control input:

|ALU Control Input|Function|
|---|---|
|0000|AND|
|0001|OR|
|0010|ADD|
|0110|SUBTRACT|

- **Load/store instructions** use the ALU to compute memory addresses by addition.
- **R-type instructions** use the ALU to perform operations like AND, OR, ADD, SUBTRACT based on instruction fields.
- **Branch if equal (`beq`)** uses the ALU to subtract two operands and check if the result is zero (for equality).

##### **Generating ALU Control Signals**
- The ALU control input is generated by a small **ALU control unit**.
- Inputs to this unit are:
    - The **7-bit `funct7`** field (bits 31:25 of the instruction)
    - The **3-bit `funct3`** field (bits 14:12)
    - A **2-bit control field called `ALUOp`** from the main control unit.
  
  ![Pasted image 20250612014535](https://github.com/user-attachments/assets/bd5d68be-9459-4881-acb7-0492417b7f7e)

#### **Immediate Generation Unit (ImmGen)**
- Takes the 12-bit offset field from the instruction.
- **Sign-extends** this 12-bit value to 32 bits by replicating the high-order sign bit.
- Provides a 32-bit signed offset to the ALU for address calculation.

Every instructions are of 4 bytes.....so every instructions starting address of all the instructions will be multiple of 4. So the offset field in Branch type instructions should be multiple of 4. Offset is 12 bits wide. So it reduces the range of jumping capability. So now we may think that we can have any offet and multiply it with 4 (left shift 2 digits). But instead in RISC V we use only even number in offset field and we multiply it by 2 (left shift by 1 digit).

RISC-V chooses to shift by only 1 bit (multiply by 2) for several practical reasons:
- **Instruction Encoding Constraints:**  
    The branch offset field in RISC-V is 12 bits wide. If you shift by 2 bits (multiply by 4), the offset field would represent units of 4 bytes, but you lose granularity for supporting 16-bit compressed instructions (which are 2 bytes long). Shifting by 1 bit (units of 2 bytes) allows RISC-V to support both 16-bit and 32-bit instructions more flexibly.
- **Support for Compressed Instructions:**  
    RISC-V’s compressed instruction extension uses 16-bit (2-byte) instructions. Using a 2-byte unit offset aligns with this, enabling branches to jump to compressed instructions as well. If the offset were in 4-byte units, branching to 2-byte aligned instructions would be impossible.
- **Hardware Simplicity and Consistency:**  
    Shifting by 1 bit is simpler and consistent with other immediate fields (like load/store offsets) that also use 2-byte units. This uniformity simplifies decoding and hardware design.
- **Branch Range vs. Encoding Tradeoff:**  
    Using 2-byte units balances the branch range and instruction encoding size. Multiplying by 4 would double the branch range but at the cost of losing support for 2-byte aligned instructions and complicating encoding.
#### **Data Memory Unit**
- Has inputs for:
    - Address (from ALU output),    
    - Write data (from register file for store),   
    - Control signals for **read** and **write**.
    - Reads data on load instructions and writes data on store instructions. 
- Reads require a control signal (`MemRead`), as reading invalid addresses can cause problems.
- Writes are edge-triggered, controlled by a write enable signal (`MemWrite`).
#### **Control Signals** 
![Pasted image 20250612015521](https://github.com/user-attachments/assets/ec7e5c1b-d67d-4d8d-a22c-f51da4ecd778)
![Pasted image 20250612020705](https://github.com/user-attachments/assets/9967130e-5e46-402f-8421-6be9187d62ca)
![Pasted image 20250612020057](https://github.com/user-attachments/assets/47a6914c-1ddc-4606-9e52-17d15548af0d)


#### **Flow of R type Instruction:**
![Pasted image 20250612012439](https://github.com/user-attachments/assets/ce9d2c6b-78cc-41a3-a2dd-b265a574edf4)


**Overview of R-Type Instructions**
- **R-type instructions** perform arithmetic and logical operations between registers.
- They use **two source registers** (`rs1` and `rs2`) and write the result to a **destination register** (`rd`).
- Examples: `add`, `sub`, `and`, `or`, `slt`, `mul`.

**R-Type Instruction Format (32 bits)**


|Field|Bits|Purpose|
|---|---|---|
|opcode|6 bits|Operation code (defines R-type)|
|rd|5 bits|Destination register|
|funct3|3 bits|Function modifier|
|rs1|5 bits|Source register 1|
|rs2|5 bits|Source register 2|
|funct7|7 bits|Function modifier|

---

##### Execution Flow for R-Type Instruction

##### 1. **Instruction Fetch (IF)**
- The **Program Counter (PC)** provides the address of the instruction.
- The instruction memory outputs the 32-bit R-type instruction at that address.
- PC is incremented by 4 to point to the next instruction.
##### 2. **Instruction Decode (ID)**
- The instruction is decoded to determine it is an R-type.
- The **register file** reads the values of the two source registers `rs1` and `rs2`.
- Control unit sets signals to indicate ALU operation and register write-back.
- The destination register `rd` is identified for later write-back.
##### 3. **Execution (EX)**
- The **ALU** receives the two register values as inputs.
- The ALU control signals (derived from `opcode`, `funct3`, and `funct7`) specify the arithmetic or logical operation (e.g., add, sub, and, or).
- The ALU performs the operation and produces the result.
- The ALU also sets flags if needed (e.g., zero flag for branch instructions, though not used here).
##### 4. **Memory Access (MEM)**
- For R-type instructions, this stage is **bypassed** because no memory access is needed.
- The result from the ALU is simply passed forward.
##### 5. **Write Back (WB)**
- The ALU result is written back into the **destination register (`rd`)** in the register file.
- The **RegWrite** control signal enables writing to the register file.
#### **Flow of Load Instruction:**

##### **Instruction:**
`lw rd, offset(rs1)`
- **rd**: destination register to load data into
- **rs1**: base register holding a memory address
- **offset**: 12-bit signed immediate added to the base address
######  **Instruction Fetch (IF)**
- The processor fetches the 32-bit load instruction from instruction memory at the address given by the Program Counter (PC).
- The PC is incremented by 4 to point to the next instruction.
##### **Instruction Decode (ID)**
- The instruction is decoded to identify it as a load instruction.
- The register file reads the contents of register `rs1` (the base address).
- The 12-bit signed immediate `offset` is extracted and sign-extended to 32 bits.
######  **Execution (EX)**
- The ALU computes the effective memory address by adding the value from `rs1` and the sign-extended `offset`.
- This calculated address points to the memory location from which data will be loaded.
###### **Memory Access (MEM)**
- The data memory is accessed at the computed address.
- Since this is a load instruction, the memory performs a **read** operation, retrieving the data stored at that address.
##### **Write Back (WB)**
- The data read from memory is written back into the destination register `rd` in the register file.
- The register file write is enabled by the control signal, updating `rd` with the loaded value.

